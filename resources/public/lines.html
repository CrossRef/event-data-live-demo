<html>
	<canvas width="1000" height="1000" id="canvas"></canvas>
	<script>
	var VelocitySmoothedValue = function(_updateFrequency) {
  		var DAMP = 5;
  		var updateFrequency = _updateFrequency;
  		var target = 0;
  		var value = 0;
  		var velocity = 0;

  		function tick() {
  			// Otherwise, don't get into ridiculous asymptotic oscillation.
  			// This also prevents zero-crossing.
  			if (Math.abs(target - value) >= 1) {
  				value += velocity;
	  			velocity = (target - value) / DAMP;
  			}
  		}

  		this.getValue = function() {
  			return value;
  		}

  		this.setTarget = function(newTarget) {
  			target = newTarget;
  		}

  		window.setInterval(tick, 1 / updateFrequency * 1000);
  		return this;
	}

	// Live windowed average over the given time period.
	var TimeWindowAverage = function(periodMs) {
		// Expected maximum per time period. Not a problem if exceeded.
		var EXPECTED_MAX = 10;

		// Ringbuffer of timestamps.
		var ringBufferSize = EXPECTED_MAX * periodMs;
		var ringBuffer = new Float64Array(ringBufferSize);
		var ringI = 0;

		// Don't worry if we over-write, it just means we saturate the counter.
		this.ping = function() {
			ringBuffer[ringI] = new Date().getTime();
			ringI = (ringI + 1) % ringBufferSize;
		}

		// How many ticks within the window?
		this.getValue = function() {
			var then = new Date().getTime() - periodMs;
			
			var value = 0;
			for (var i=0;i < ringBufferSize; i++) {
				if (ringBuffer[i] > then) {
					value++;
				}
			}
			return value;
		}

		return this;
	}

	// Velocity smoothed tick rate.
	var SmoothedRateCounter = function(_updateFrequency, _periodMs) {
		var updateFrequency = _updateFrequency;
		var periodMs = _periodMs;
		var value = new VelocitySmoothedValue(updateFrequency);
		var average = new TimeWindowAverage(periodMs);

		this.ping = function() {
			average.ping();
		}

		this.getValue = function() {
			return value.getValue();
		}

		function tick() {
			value.setTarget(average.getValue());
		}

		// updateFrequency used both to clock smoother and poll to update smoother target value.
		window.setInterval(tick, 1 / updateFrequency * 1000);

		return this;
	}

	// Appears to be int array, but loses precision toward the end.
	// First region has full precision, second region has half etc.
	var BASE = 1.01;
	var VagueningRateHistory = function(_size) {
		var size = _size;
		var logBase = BASE;
		var allocatedSize = Math.floor(Math.log(size) / Math.log(logBase));

		var values = new Float32Array(allocatedSize);		

		this.getValue = function(logicalIndex) {
			var offset = Math.floor(Math.log(logicalIndex) / Math.log(logBase));
			var multipler = Math.pow(offset, logBase);

			return values[offset] / multipler;
		}

		this.getMaxValue = function() {
			var maxValue = 0;
			for (var i = 0; i < allocatedSize; i++) {
				var numRepresented = Math.pow(i, logBase);
				for (var j=0; j < numRepresented; j++) {
					maxValue = Math.max(maxValue, values[i] / numRepresented);
				}
			}
			return maxValue;
		}

		// Optionally push a value on the end and shift down by one logical value.
		// This is the only way data gets in!
		this.shift = function(value) {
			maxValue = 0;
			for (var i=allocatedSize-1;i>1;i--) {

				// If we borrow zero we'll get a divide-by-zero, and in that case there's nothing to shift on.
				var borrowedValue = values[i-1] / Math.pow((i-1), logBase);
				values[i-1] -= borrowedValue;

				if (!isNaN(borrowedValue)) {
					values[i] += borrowedValue;// * Math.pow(i, logBase);	
					maxValue = Math.max(values[i]||0, maxValue / Math.pow(i, logBase));
				}

			}

			values[1] = value || 0;
			values[0] = value || 0;

		}

		this.iterateLogical = function(callback) {
			var k = 0;
			for (var i = 0; i < allocatedSize; i++) {
				var numRepresented = Math.pow(i, logBase);
				for (var j=0; j < numRepresented; j++) {
					callback(k, values[i] / numRepresented);
					k++;
				}
			}
		}

		// Iterate in the logical value domain; don't interpolate x values.
		this.iterate = function(callback) {
			var x = 0;
			for (var i = 0; i < allocatedSize; i++) {
				var numRepresented = Math.pow(i, logBase);
				callback(x, values[i] / numRepresented);
				x += numRepresented;
			}	
		}

		return this;
	}

	// A tone on the whole-tone-scale that's modulated by a value.
	var AwfulNoise = function(_i, _bus, _audio) {
		var value = 0;
		var i = _i;
		var bus = _bus;
		var audio = _audio;

		// Frequency for note i plus modulation.
		function freqFor(i, modulation) {
			return Math.pow(2, ((((i + 1) * 2 + Math.sqrt(modulation)))/12)) * 440;
		}

		var sourceGain = audio.createGain();

		sourceGain.connect(bus);
		sourceGain.gain.value = 0.1;
		var oscillator = audio.createOscillator();
		oscillator.type = 'triangle';
		
		oscillator.connect(sourceGain);
		oscillator.gain = 0.1;
		oscillator.start();

		this.setValue = function(_value) {
			value = _value;
			oscillator.frequency.value = freqFor(i, value);
		}

		return this;
	}

	// Plot the rate of a number of things, and the history.
	var MultipleRatePlotter = function(_canvas, _tickHz, _countWindowMsecs,
									   _historySize) {
		var canvas = _canvas;
		var tickHz = _tickHz;
		var countWindowMsecs = _countWindowMsecs;
		var historySize = _historySize;

		// Keep keys into things so they can be added as we find out about them without disrupting the visual order.
		var things = {};
		var thingNames = [];

		// Audio
		var audio = new (window.AudioContext || window.webkitAudioContext)();
		var gain = audio.createGain();
		gain.connect(audio.destination);
		gain.gain.setValueAtTime(0.05, 0);

		var delay = audio.createDelay();
		delay.delayTime.value = 0.5;

		var feedback = audio.createGain();
		feedback.gain.value = 0.1;

		delay.connect(feedback);
		feedback.connect(delay);

		delay.connect(gain);

		var bus = audio.createGain();
		bus.connect(delay);
		bus.connect(gain);

		// Graphics
		var context = canvas.getContext("2d");
		var width;
		var height;
	    function resize() {
	    	width = window.innerWidth;
	    	height = window.innerHeight;
	    	canvas.width = width;
	    }
	    resize();
	    window.addEventListener("resize", resize);

		this.ping = function(thingName) {
			var thing = things[thingName];
			if (!thing) {
				thing = {history: new VagueningRateHistory(historySize),
				         counter: new SmoothedRateCounter(tickHz, _countWindowMsecs),
				     	 awfulNoise: new AwfulNoise(thingNames.length, bus, audio)};
				thingNames.push(thingName);
				things[thingName] = thing;
			}

			thing.counter.ping();
		}

		function render() {
			canvas.width = canvas.width;

			if (thingNames.length == 0) {
				context.fillStyle = "#101010";
				context.font = "40px sans-serif"
				context.fillText("Waiting for something to happen...",
								Math.floor(width / 10),
								Math.floor(height / 4));
				return
			}

			var LANE_MARGIN = 10;
			var laneHeight = height / thingNames.length - LANE_MARGIN;

			var laneSizeOverall = laneHeight + LANE_MARGIN;

			for (var thingI = 0; thingI < thingNames.length; thingI++) {
				var thingName = thingNames[thingI];
				var thing = things[thingName];

				thing.awfulNoise.setValue(thing.counter.getValue());

				var laneOffset = thingI * laneSizeOverall;
				var maxValue = thing.history.getMaxValue();
				
				var yScale = laneHeight / Math.max(maxValue, 1);
				var xScale = width / historySize;


				// Background
				context.fillStyle = "#f0f0f0";
				context.fillRect(0, thingI * laneSizeOverall, width, laneSizeOverall - LANE_MARGIN)

				// Value tracker
				context.fillStyle = "#e0e0e0";
				context.fillRect(0, Math.floor(thing.counter.getValue()*yScale-2 + laneOffset), width, 4)

				// Text
				context.fillStyle = "#a0a0a0";
				context.font = "" + (laneHeight/2) + "px sans-serif";
				context.fillText(thingName + " " + Math.floor(thing.counter.getValue()*60) + " per minute",
								LANE_MARGIN,
								thingI * laneSizeOverall + (laneSizeOverall/2));


				

				context.beginPath();
				var start = true;
				thing.history.iterate(function(x, y) {
					var backwardX = width - Math.floor(x * xScale);
					if (!start) {
						context.moveTo(backwardX,Math.floor(y * yScale) + laneOffset);
						start = false;
					} else {
						context.lineTo(backwardX,Math.floor(y * yScale) + laneOffset);
					}
				});

				context.stroke();


			}
		}
		
		function tick() {
			// Shift the current value of each thing into its history.
			for (var i = 0; i < thingNames.length; i++) {
				things[thingNames[i]].history.shift(things[thingNames[i]].counter.getValue());
			}

			render();
		}

		window.setInterval(tick, (1 / tickHz) * 1000);
	}

	var canvas = document.getElementById("canvas");
	var TICK_HZ = 20;
	var COUNT_WINDOW_MSECS = 1000; // count per second
	var HISTORY_SIZE = 4000;
	var plotter = new MultipleRatePlotter(canvas, TICK_HZ, COUNT_WINDOW_MSECS,
										  HISTORY_SIZE);
	

	var url = "wss://live.eventdata.crossref.org/socket";
    
    var socket = new WebSocket(url);

    socket.onopen = function() {
      socket.send("items 20");
      socket.send("start");
    }

    socket.onmessage = function(item) {
        var data = JSON.parse(item.data);
        plotter.ping(data.source_id);
    };
   
	</script>

	<style>
	body, html { margin: 0px;} 
	</style>
</html>