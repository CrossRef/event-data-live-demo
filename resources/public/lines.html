<html>
	<canvas width="1000" height="1000" id="canvas"></canvas>
	<script>
		
		var SOURCES = ["wikipedia","crossref", "datacite", "hypothesis", "newsfeeds", "reddit", "reddit-links", "stackexchange", "twitter", "web", "wordpressdotcom"];
		// SOURCES = ["wikipedia"];

		var PIXEL_WIDTH = 1000;
		var PIXEL_HEIGHT = 500;
		var NUM_VALUES = 12000;
		var LANE_SPACING = 10; // pixels between lanes.
		var WINDOW_HZ = 30;

		// Count per second.
		var PER_WHAT = 1000;

		function freqFor(i, value) {
			
			return Math.pow(2, ((((i + 1) * 2 + Math.sqrt(value)))/12)) * 440;
		}


		function velocityWindowedAverage(updateHz) {
			var w = {events: []};
			var lastValue = 0;
			var velocity = 0;
			var smoothedValue = 0;
			var DAMP = 2;

			w.ping = function() {
				w.events.push(new Date());
			}

			w.tick = function() {
				var filtered = [];
				var cutoff = new Date() - PER_WHAT;
				
				for (var i = 0; i < w.events.length; i++) {
					if (w.events[i] > cutoff) {
						filtered.push(w.events[i]);
					}
				}

				w.events = filtered;

				var currentVal = w.events.length;
				velocity = (currentVal - lastValue) / 2;
				velocity /= DAMP;

				lastValue += velocity;
			};

			w.getValue = function() {
				return lastValue;
			}

			setInterval(function() {w.tick();}, (1 / updateHz) * 1000);

			return w;
		}

		function windowedAverage(_length) {
			var length = _length;
			var start = 0
			var average = {ringBuffer: new Float32Array(length)};

			average.reset = function() {
				average.ringBuffer.fill(0);
			}

			average.fill = function(value) {
				average.ringBuffer.fill(value);
			}


			average.push = function(value) {
				average.ringBuffer[start] = value;
				start = ++ start % length;
			}

			average.getValue = function() {
				return average.ringBuffer.reduce(function(a,b){ return a + b}) / length;
			}

			return average;
		}

		function autoShiftingAverage(_length, _shiftHz) {
			var length = _length;
			var shiftHz = _shiftHz;
			var start = 0
			var average = {ringBuffer: new Float32Array(length)};

			average.fill = function(value) {
				average.ringBuffer.fill(value);
			}

			average.reset = function() {
				average.ringBuffer.fill(0);
			}

			average.shift = function () {
				start = ++ start % length;
				average.ringBuffer[start] = 0;
			}

			window.setInterval(function() {average.shift()}, (1 / shiftHz) * 1000);

			average.incrBy = function(value) {
				average.ringBuffer[start] += value;
			}

			average.getValue = function() {
				return average.ringBuffer.reduce(function(a,b){ return a + b}) / length;
			}

			return average;
		}

		function construct(_sources, _pixelWidth, _pixelHeight, _numValues, _graphics, _canvas, _windowHz) {
			
			var structure = {};
			var audio = new (window.AudioContext || window.webkitAudioContext)();
			var gain = audio.createGain();
			gain.connect(audio.destination);
			gain.gain.value = 0.05;
	
			var delay = audio.createDelay();
			delay.delayTime.value = 0.5;

			var feedback = audio.createGain();
			feedback.gain.value = 0.1;

			delay.connect(feedback);
			feedback.connect(delay);

			
			delay.connect(audio.destination);


			var sources = _sources;
			var pixelWidth = _pixelWidth;
			var numValues = _numValues;
			var pixelHeight = _pixelHeight;
			var maxHeightPerSource = pixelHeight / sources.length;
			var graphics = _graphics;
			var canvas = _canvas;
			var windowHz = _windowHz;

			for (var i = 0; i < sources.length; i++) {
				let source = sources[i];

				var sourceGain = audio.createGain();

				sourceGain.connect(delay);
				sourceGain.connect(audio.destination);

				sourceGain.gain.value = 0.1;

				var oscillator = audio.createOscillator();
				oscillator.type = 'triangle';
				oscillator.frequency.value = freqFor(i, 0);
				oscillator.connect(sourceGain);
				oscillator.gain = 0.1;
				oscillator.start();


				structure[source] = {
					// Source values, time-oriented.
					values: new Float32Array(numValues),

					// Scaled per-pixel values.
					pixels: new Float32Array(pixelWidth),
					
					window: velocityWindowedAverage(windowHz),

					oscillator: oscillator,
					gain: sourceGain
				}
			}



			// Shift but don't reset value (so it can be updated asycnronously).
			structure.shift = function() {
				for (var i = 0; i < sources.length; i++) {

					let source = sources[i];
					let values = structure[source].values;

					values[0] = structure[source].window.getValue();

					for (var j = numValues; j > 0 ; j -= 1) {
						values[j] = values[j-1];
					}
				}
			}

			structure.ping = function (source) {
	           structure[source] && structure[source].window.ping();
			}
			
			function scale(t) {
				return Math.floor(t*t*2);
			}

			function project(from, to) {
				var max = 1;
				for (var j = 0; j < to.length - 1; j++) {
					var lBound = scale(j);
					var uBound = scale(j+1);
					if (uBound > from.length) {
						break;
					}

					to[j] = 0;

					var c = 0;
					var v = 0;
					for (var x = lBound; x < uBound; x++) {
						v += from[x];
						c++;
					}
					v /= Math.max(c, 1);
					
					to[j] = v;
					max = Math.max(max, v);
				}

				for (var j = 0; j < to.length - 1; j++) {
					to[j] /= max;
				}
			}

            structure.project = function() {
	            structure.project = function () {
                    for (var i = 0; i < sources.length; i++) {
                            let source = sources[i];
                            let values = structure[source].values;
                            let pixels = structure[source].pixels;
                            project(values, pixels);
                    }
                }
            }

			structure.draw = function() {
				canvas.width = canvas.width;
				graphics.font = "" + Math.ceil(maxHeightPerSource * 0.5) + "px sans-serif";

				for (var i = 0; i < sources.length; i++) {
					graphics.setFillColor("#f0f0f0");
					graphics.fillRect(0,
									  (i * maxHeightPerSource) + LANE_SPACING / 2,
									  pixelWidth,
									  maxHeightPerSource - (LANE_SPACING / 2));

					let source = sources[i];
					let pixels = structure[source].pixels;
					
					graphics.setFillColor("#ccc");

					graphics.fillText(source + " " + Math.ceil(structure[source].window.getValue()) + " per second", 10, (i + 0.5) * maxHeightPerSource);

					var begin = false;
					
					graphics.setFillColor("#111");

					graphics.beginPath();

					var y = 0;
					var yVelocity = 0;
					var averageY = windowedAverage(10);

					for (var j = 0; j < numValues; j++) {
						if (pixels[j] > 0) {
							if (!begin) {
								graphics.beginPath();
								averageY.fill((i * maxHeightPerSource) + (maxHeightPerSource - pixels[j] * maxHeightPerSource));
								graphics.moveTo(pixelWidth, averageY.getValue());
								begin = true;
							} else {
								
								var newY = (i * maxHeightPerSource) + (maxHeightPerSource - pixels[j] * maxHeightPerSource);
								averageY.push(newY);
								graphics.lineTo(pixelWidth-j, averageY.getValue());

								// graphics.fillRect(pixelWidth-j, newY, 1, 1)
							}
						}
					}
					graphics.stroke();
				}
			}

			structure.render = function() {
				structure.project();
				structure.draw();

				for (var i = 0; i < sources.length; i++) {
					var source = sources[i];
					structure[source].oscillator.frequency.value = freqFor(i, structure[source].window.getValue());
					structure[source].gain.gain.value = structure[source].window.getValue() / 30 + 0.01;
				}
			}
		
			structure.setValue = function(sourceName, newValue) {
				structure[sourceName].values[0] = newValue;
			}

			return structure;
		}

		var canvas = document.getElementById("canvas");
		var graphics = canvas.getContext("2d");

		var structure = construct(SOURCES, PIXEL_WIDTH, PIXEL_HEIGHT, NUM_VALUES, graphics, canvas, WINDOW_HZ);		

		function shift() {
			structure.shift();
		}

		function render() {
			structure.render();
		}

		window.setInterval(shift, 10);
		window.setInterval(render, 100);

		var url = "wss://live.eventdata.crossref.org/socket";
        
        var socket = new WebSocket(url);

        socket.onopen = function() {
          socket.send("items 20");
          socket.send("start");
        }


        socket.onmessage = function(item) {
            var data = JSON.parse(item.data);
            structure.ping(data.source_id);
        };
	</script>
</html>